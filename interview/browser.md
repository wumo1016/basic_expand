## 从输入url到页面加载完成 发生了什么(2+3+5)
  - url解析
  - 检查资源缓存
    - 使用缓存
    - 网路请求
      - DNS解析(将url解析成ip)
      - 建立TCP链接 发起http请求
      - 服务器收到请求 并返回响应结果
  - 浏览器渲染
    - 解析html => `dom-tree`(document) 解析css => `css-tree`(document.styleSheets)
    - 构建`render-tree`: 将`css-tree`合并到`dom-tree`上 计算每个dom节点的样式
    - 构建`layout-tree`: 将可见的元素添加到布局树中 计算每个dom节点的位置
    - 构建`layer-tree`: 根据元素的定位属性、层级属性等构建层级树
    - 绘制页面: 根据不同的图层树进行绘制 最终合并成一个页面

## 从输入url到页面加载完成 发生了什么(细化版)
  - 网络请求
    - url解析
      - 一个完整的URL应该是: 协议+ip+端口+路径[+参数][+锚点]
      - 浏览器会判断输入的内容是一个url还是一个关键字
        - 关键字: 会自动拼接到默认搜索引擎后面的参数部分去 从而组成一个完整的url
      - 然后浏览器会对非安全字符进行转义
        - 安全字符: 数字、英文字母、少数符号
        - 非安全字符: 汉字、特殊字符(= ? & 因为这些特殊字符会和url本身的字符产生歧义)
          - 浏览器对非安全字符转义的编码叫 `百分号编码` (因为它使用%加上两位的16进制数表示)
      - `encodeURI` 和 `encodeURIComponent`
        - encodeURI:  不会编码 `?&=` 这些url内置字符 
        - encodeURIComponent: 会编码所有字符
    - 检查资源缓存
        - 强缓存 直接设置过期时间 未到期直接使用缓存
          - 设置Cache-Control：max-age=xxx(Expires)
          - 从控制台请求可以看到这类请求直接返回200 size是 `memory cache`(资源从内存中取出) 或 `disk cache`(资源从磁盘中取出)
        - 协商缓存
          - 设置响应头 Last-Modified-Since
          - 下一次请求头带上 If-Modified-Since 然后与最后修改时间对比 相同就返回304
          - 缺点：有可能修改时间变了 但是内容没变
        - 文件指纹：根据文件内容生成一段密钥(摘要)
          - 设置响应头 Etag 指纹
          - 下一次请求会自定带上 If-none-match 如果相同就返回304状态码
    - DNS解析
      - 如果没有成功使用本地缓存 就需要发起网络请求了 首先会进行DNS解析
        - 搜索过程: 浏览器DNS缓存 => 操作系统DNS缓存 => 路由器的DNS缓存 => 向服务商的DNS服务器查询 => 向全球13台根域名服务器查询
        - 为了节省时间 可以进行预DNS解析 `<link rel="dns-prefetch" href="http://www.baidu.com" />` 为了保证响应的及时性 它使用的是UDP协议
    - TSL协商密钥(HTTPS的S)
    - 建立TCP连接
    - 发送http请求与接收响应
    - 关闭TCP连接
  - 浏览器渲染
    - 构建DOM树
    - 样式计算
    - 布局定位
    - 图层分层
    - 图层绘制
    - 显示

## preload、prefetch有什么区别
  - preload: 以高优先级加载资源 常用于当前页面立即使用的资源
  - prefetch: 以低优先级加载资源 将来会使用的资源

## 状态码
  - 1xx
    - 101：websocket
  - 2xx：表示成功
    - 200：成功
    - 204：成功了但是没有返回具体的内容
    - 206：分片传输
  - 3xx：重定向
    - 301：永久重定向
    - 302：临时重定向
    - 304：使用缓存
  - 4xx：客户端错误
    - 400：参数错误 服务端不知道发送的是什么
    - 401：未登录 没有权限
    - 403：已登录 没有权限(token过期等)
    - 404：请求的url不存在
    - 405：请求的方法服务端不支持
  - 5xx：服务端错误
    - 500：服务器内部错误
    - 502：代理请求 无法响应
    - 504：请求超时 无法响应

## 三次握手与四次挥手
  - 三次握手
    - 客户端 => SYN => 服务器
    - 服务器 => SYN + ACK => 客户端
    - 客户端 => ACK => 服务端
  - 四次挥手
    - 客服端 => FIN => 服务器
    - 服务端 => ACK => 客户端(此时数据可能没有传输完毕 所以不能合并)
    - 服务端 => FIN => 客户端
    - 客户端 => ACK => 服务端

## 五大浏览器及其内核
  - Chrome：blink(基于webkit)
  - Firefox：gecko
  - Safari：webkit
  - Opera：blink
  - IE：trident

## TCP和UDP
  - TCP
    - 建立链接和断开链接都需要握手 在数据传输的过程中 会通过各种算法保证数据的可靠性
    - ARQ协议：超时重传机制
  - UDP
    - 首先UDP是面向无连接的 不需要握手 可以直接发送数据
    - 只是数据的搬运工 并不做处理
      - 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
      - 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作
    - 缺点：不知道对方有没有收到
    - 传输方式：支持一对一、一对多、多对多
    - 使用场景：直播 游戏

## HTTP
  - HTTP/0.9：没有请求头和请求体，使用ASCII来传输HTML
  - HTTP/1.0：增加请求头和响应头，实现多类型数据传输
  - HTTP/1.1：默认开启持久链接，一个TCP上可以开启多个HTTP请求，一个域名最多维护6个TCP持久链接，解决队头阻塞问题(但是服务端要按顺序依次处理请求)，引入
  客户端cookie机制
  - HTTP/2.0
    - 解决网络带宽使用低(多个TCP竞争带宽)，采用多路复用机制(一个域名使用一个TCP持久链接)，服务端推送
    - http2采用文本 HTTP2采用二进制编码
  - HTTP/3.0：解决TCP队头阻塞问题，采用QUIC协议，QUIC协议基于UDP协议
  - HTTPS：还是通过HTTP来传输信息，但是信息通过TLS/SSL协议进行了加密(对称加密和非对称加密)
  - HTTP与HTTPS的主要区别
    - 后者需要到CA申请证书
    - 前者是明文传输 后者使用TSL/SSL的加密协议进行传输
    - 用的端口不同 前者使用的80端口 后者使用的是443端口

## 手写ajax
  - readyState
    - 0：请求未初始化
    - 1：服务器链接已建立
    - 2：请求已接收
    - 3：请求处理中
    - 4：请求已完成 且响应已经就绪

## 图片使用base64编码的优缺点
  - 优点
    - 较少http请求
  - 缺点
    - 编码的文件会比原来大1/3
    - 无法直接缓存 只能通过html css缓存
    - ie8以前不支持
    - 一般只用于小图片的引入