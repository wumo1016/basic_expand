## HTTP 是什么

- 超文本传输协议: 是一个在计算机世界里专门在两点之前传输超文本(文字、图片、音频、视频)数据的约定和规范
  - 超文本: 文字、图片、音频、视频等数据
  - 传输: 就是两点之间传输数据
  - 协议: 是一个在计算机世界里的协议, 它使用计算机能够理解的的语言确立了一种计算机之间交流通信的规范, 以及各种控制和错误处理方式

## HTTP 常见字段

- Host: 客户端发送请求时, 用来指定服务器的域名
- Content-Length: 表示本次响应的数据长度
- Content-Type: 表示本次响应的数据格式 (请求时可以通过请求头 Accept 设置可接受的数据格式)
- Content-Encoding: 表格本次响应的数据压缩方法(gzip、deflate) (请求时可以通过请求头 Accept-Encoding 设置可接受的数据格式)
- Connection: keep-alive 保持 TCP 持久连接, 以便其他请求复用(HTTP1.1 默认连接都是持久连接, 加这个字段是为了兼容老版本的 HTTP)

## 强制缓存和协商缓存

- 强缓存 (主要通过两个响应头实现 (Cache-Control 优先级更高))
  - Cache-Control
    - 相对时间(单位 s)
    - no-cache: 不缓存，但缓存中有，每次询问服务器
    - no-store: 不缓存
  - Expires: 绝对时间
- 协商缓存 (基于两种头部实现) (Etag 优先级更高)
  - 文件修改时间
    - 响应头中的 Last-Modified 表示文件最后的修改时间
    - 请求头中的 If-Modified-Since 再次发起请求的时候 带上 Last-Modified 服务器进行比对 Last-Modified 和 If-Modified-Since
      - Last-Modified > If-Modified-Since : 返回 200
      - If-Modified-Since > Last-Modified : 返回 304
  - 文件指纹
    - 响应头中的 Etag
    - 请求头中的 If-None-Match 再次发起请求的时候带上 Etag 的值 服务器进行比对 一样就返回 304 不一样就返回 200

## HTTP/1.1

- 长连接
  - 早期 HTTP1.0 一个很大的问题就是，每发起一个请求，都要建立一次 TCP 连接，而且都是串行请求，做了无谓的连接建立和断开
  - HTTP1.1 默认持久连接，只要没有任意一端明确提出断开连接，则保持 TCP 连接状态(当某个长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接)
  - 默认在请求的时候 增加 connection:keep-alive (只有一次请求应答后才能复用)
- 管道网络传输
  - 可以同时发起多个请求，但服务器必须按照请求发送的顺序发送这些请求的响应
  - 虽然请求队头不阻塞了，但没有解决响应队头阻塞
- 队头阻塞
  - 响应必须按顺序返回(如果前面的响应未完成，后面的则需要等待) 这称为队头阻塞
  - 所以 HTTP1.1 管道解决了请求的队头阻塞，但没有解决响应的队头阻塞
- 无状态
  - 例如需要权限的操作 每个接口都需要验证身份 它并不知道这些请求时相互关联的
  - 解决: 使用 cookie 等
- 不安全
  - 窃听风险: 通信使用明文 信息容易被窃取
  - 冒充风险: 不验证通信方的身份 因此很有可能伪装
  - 篡改风险: 无法验证报文的完整性 可能遭受篡改
  - 解决: 使用 HTTPS，加入 SLL/TLS

## HTTP/2

- 头部压缩
  - 如果同时发出多个请求，他们的头是一样的或者类似的，协议会帮你消除重复的部分
  - 利用 HPACK 算法: 在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了
- 二进制格式
  - 头信息和数据体都是二进制，并且统称为帧: 头信息帧和数据帧
- 数据流
  - HTTP/2 的数据包不是按顺序发送的，每个请求或响应的数据包，都称为一个数据流，每个数据流都有一个独一无二的编号(Stream ID)
  - 客户端建立的 Stream ID 必须是奇数 服务端建立的 Stream ID 必须是偶数
- 多路复用
  - 可以在一个请求中并发多个请求或响应，而且不用一一对应
- 服务器推送
  - 服务器可以主动向客户端发送消息

## HTTPS

- 介绍
  - TLS 由 SSL 发展而来，SSL 发展到第三代就改成了 TLS
- 特点
  - 数据传输
    - HTTPS 解决了 HTTP 不安全的缺陷 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议 使得报文能够加密传输
    - 保证数据安全传输(密文、防篡改)
      - 混合加密(对称+非对称)
        - 通过非对称加密来解决密钥传输问题
        - 数据传输利用对称加密
      - 摘要算法(哈希算法)
        - 传输数据时，对内容计算出一个指纹，然后一起传给对方；对方收到后，业绩算一下指纹，根据指纹的异同哦按段是否呗篡改
        - 通过哈希算法可以确保内容不会被篡改，但是不能保证[内容+hash 值]不会被中间人替换，缺少收到的消息是否真的来自于发送方的证明
          - 例如你请假，一般需要家长的签名，但是你会模仿你家长，这个时候老师就需要确认签名是否是家长签的，一般电话或者视频来确认，而计算机里就通过非对称加密算法来解决
    - 解决了 HTTP 的三个风险
      - 窃听风险(比如通信链路上可以获取通信内容) => 使用信息加密(交互信息无法被窃取) => 混合加密(现信息的机密性，解决了窃听的风险)
      - 篡改风险(比如强制植入垃圾广告，视觉污染) => 使用校验机制(无法篡改通信内容，篡改了就不能正常显示) => 摘要算法(实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险)
      - 冒充风险(比如冒充淘宝网站，用户钱容易没) => 身份证书(证明淘宝是真的淘宝网) => 数字证书(将服务器公钥放入到数字证书中，解决了冒充的风险)
  - 连接建立
    - HTTP 传输建立相对简单 在 TCP 三次握手之后即可传输数据 但 HTTPS 还需要进行 SSL/TLS 的握手过程
  - 端口
    - HTTP 的端口是 80 HTTP 的端口是 443
  - 证书
    - HTTPS 需要向 CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的

## 非对称加密算法

- 组成
  - 一个公钥，可以公开给所有人
  - 一个私钥，由本人管理，不可泄漏
- 加密方式(双向加密)
  - [公钥加密，私钥解密]
    - 为了保证内容传输的安全。因为只有持有私钥的人，才能解密出实际的内容
  - [私钥加密，公钥解密]
    - 为了保证消息不会被冒充。如果公钥能正常解密内容，就能证明这个内容就是持有私钥身份的人发送的
- 备注
  - 一般不会使用非对称加密来传输内容，因为非对称加密的计算比较耗费性能
  - 所以主要用途是通过[私钥加密，公钥解密]的方式来确认消息的身份(常说的数字签名算法，就是这种方式，只不过它加密的不是内容本身，而是对内容的 hash 值加密)

## 对称加密

- AES:
- Chacha20:
