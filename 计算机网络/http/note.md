## HTTP 是什么

- 超文本传输协议: 是一个在计算机世界里专门在两点之前传输超文本(文字、图片、音频、视频)数据的约定和规范
  - 超文本: 文字、图片、音频、视频等数据
  - 传输: 就是两点之间传输数据
  - 协议: 是一个在计算机世界里的协议, 它使用计算机能够理解的的语言确立了一种计算机之间交流通信的规范, 以及各种控制和错误处理方式

## HTTP 常见字段

- Host: 客户端发送请求时, 用来指定服务器的域名
- Content-Length: 表示本次响应的数据长度
- Content-Type: 表示本次响应的数据格式 (请求时可以通过请求头 Accept 设置可接受的数据格式)
- Content-Encoding: 表格本次响应的数据压缩方法(gzip、deflate) (请求时可以通过请求头 Accept-Encoding 设置可接受的数据格式)
- Connection: keep-alive 保持 TCP 持久连接, 以便其他请求复用(HTTP1.1 默认连接都是持久连接, 加这个字段是为了兼容老版本的 HTTP)

## 强制缓存和协商缓存

- 强缓存 (主要通过两个响应头实现 (Cache-Control 优先级更高))
  - Cache-Control
    - 相对时间(单位 s)
    - no-cache: 不缓存，但缓存中有，每次询问服务器
    - no-store: 不缓存
  - Expires: 绝对时间
- 协商缓存 (基于两种头部实现) (Etag 优先级更高)
  - 文件修改时间
    - 响应头中的 Last-Modified 表示文件最后的修改时间
    - 请求头中的 If-Modified-Since 再次发起请求的时候 带上 Last-Modified 服务器进行比对 Last-Modified 和 If-Modified-Since
      - Last-Modified > If-Modified-Since : 返回 200
      - If-Modified-Since > Last-Modified : 返回 304
  - 文件指纹
    - 响应头中的 Etag
    - 请求头中的 If-None-Match 再次发起请求的时候带上 Etag 的值 服务器进行比对 一样就返回 304 不一样就返回 200

## HTTP/1.1

- 长连接
  - 早期 HTTP1.0 一个很大的问题就是，每发起一个请求，都要建立一次 TCP 连接，而且都是串行请求，做了无谓的连接建立和断开
  - HTTP1.1 默认持久连接，只要没有任意一端明确提出断开连接，则保持 TCP 连接状态(当某个长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接)
  - 默认在请求的时候 增加 connection:keep-alive (只有一次请求应答后才能复用)
- 管道网络传输
  - 可以同时发起多个请求，但服务器必须按照请求发送的顺序发送这些请求的响应
  - 虽然请求队头不阻塞了，但没有解决响应队头阻塞
  - 虽然支持，但是存在很多问题，浏览器默认事关闭的
- 队头阻塞
  - 响应必须按顺序返回(如果前面的响应未完成，后面的则需要等待) 这称为队头阻塞
  - 所以 HTTP1.1 管道解决了请求的队头阻塞，但没有解决响应的队头阻塞
- 无状态
  - 例如需要权限的操作 每个接口都需要验证身份 它并不知道这些请求时相互关联的
  - 解决: 使用 cookie 等
- 不安全
  - 窃听风险: 通信使用明文 信息容易被窃取
  - 冒充风险: 不验证通信方的身份 因此很有可能伪装
  - 篡改风险: 无法验证报文的完整性 可能遭受篡改
  - 解决: 使用 HTTPS，加入 SLL/TLS

## HTTP/2

- 头部压缩
  - 如果同时发出多个请求，他们的头是一样的或者类似的，协议会帮你消除重复的部分
  - 利用 HPACK 算法: 在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了
    - 静态字典
      - 包含 61 个高频的头部
    - 动态字典
      - 第一次发送的时候，客户端和服务器都会更新自己的动态表，下一次请求的时候，就可以复用了，前提必须是同一个连接
    - Huffman 编码（霍夫曼编码）[https://www.rfc-editor.org/rfc/rfc7541]
- 二进制帧

  - 头信息和数据体都是二进制，并且统称为帧: 头信息帧和数据帧
  - 结构
    - 头信息帧
      - 帧长度
      - 帧类型(8 位) + 标志位(8 位)
      - R(1 位，保留位) + 流标识位(31 位，表示该帧属于哪个流，从而组装数据)
    - 数据帧
      - 它是(通过 HPACK 算法压缩过的 HTTP 头部)和包体

- 并发传输(多路复用)

  - 可以在一个请求中并发多个请求或响应，而且不用一一对应
  - 引入流的概念
    - 组成
      - 一个 TCP 可以包含多个 Stream
      - 一个 Stream 可以包含多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头和体构成
      - Message 里包含多个数据帧
    - HTTP/2 的数据包不是按顺序发送的，每个请求或响应的数据包，都称为一个数据流，每个数据流都有一个独一无二的编号(Stream ID)，接收端可以通过 Stream ID 有序的组成 HTTP 消息
    - 不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应
    - 客户端建立的 Stream ID 必须是奇数 服务端建立的 Stream ID 必须是偶数
    - 同一个域名访问多个文件的请求也可以复用一个 tcp 连接

- 服务器推送
  - 服务器可以主动向客户端发送数据，无需客户端请求
- 缺点
  - 队头阻塞
    - 只不过问题不在 HTTP 层，而是在 TCP 层(因为 TCP 层必须保证收到得字节数据是连续并且完整得)

## HTTPS

- 介绍
  - TLS 由 SSL 发展而来，SSL 发展到第三代就改成了 TLS
- 特点
  - 数据传输
    - HTTPS 解决了 HTTP 不安全的缺陷 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议 使得报文能够加密传输
    - 保证数据安全传输(密文、防篡改)
      - 混合加密(对称+非对称)
        - 通过非对称加密来解决密钥传输问题
        - 数据传输利用对称加密
      - 摘要算法(哈希算法)
        - 传输数据时，对内容计算出一个指纹，然后一起传给对方；对方收到后，业绩算一下指纹，根据指纹的异同哦按段是否呗篡改
        - 通过哈希算法可以确保内容不会被篡改，但是不能保证[内容+hash 值]不会被中间人替换，缺少收到的消息是否真的来自于发送方的证明
          - 例如你请假，一般需要家长的签名，但是你会模仿你家长，这个时候老师就需要确认签名是否是家长签的，一般电话或者视频来确认，而计算机里就通过非对称加密算法来解决
          - 签名只有是你家长签的，才能被老师正确解密，还缺少一个环节，就是如何确认公钥和私钥是正确的(假如你趁机将老师手里的公钥换掉，就是伪造你家人的电话等)
          - 所以你家人将他的公钥拿到警察局，然后将[个人信息+公钥+数字签名]打包生成一个数字证书，老师接收到请假条时会先向警察局数字证书是否合法
      - 数字证书
        - CA(数字证书认证机构)机构，将服务器公钥放在证书中
    - 解决了 HTTP 的三个风险
      - 窃听风险(比如通信链路上可以获取通信内容) => 使用信息加密(交互信息无法被窃取) => 混合加密(现信息的机密性，解决了窃听的风险)
      - 篡改风险(比如强制植入垃圾广告，视觉污染) => 使用校验机制(无法篡改通信内容，篡改了就不能正常显示) => 摘要算法(实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险)
      - 冒充风险(比如冒充淘宝网站，用户钱容易没) => 身份证书(证明淘宝是真的淘宝网) => 数字证书(将服务器公钥放入到数字证书中，解决了冒充的风险)
    - 备注
      - 通过哈希算法保证数据的完成性
      - 通过数字签名保证数据的来源可靠性(非对称加密)
      - 通过数字证书来保证密钥的可靠性
  - 连接建立
    - HTTP 传输建立相对简单 在 TCP 三次握手之后即可传输数据 但 HTTPS 还需要进行 SSL/TLS 的握手过程
  - 端口
    - HTTP 的端口是 80 HTTP 的端口是 443
  - 证书
    - HTTPS 需要向 CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的

## 非对称加密算法

- 组成
  - 一个公钥，可以公开给所有人
  - 一个私钥，由本人管理，不可泄漏
- 加密方式(双向加密)
  - [公钥加密，私钥解密]
    - 为了保证内容传输的安全。因为只有持有私钥的人，才能解密出实际的内容
  - [私钥加密，公钥解密]
    - 为了保证消息不会被冒充。如果公钥能正常解密内容，就能证明这个内容就是持有私钥身份的人发送的
- 备注
  - 一般不会使用非对称加密来传输内容，因为非对称加密的计算比较耗费性能
  - 所以主要用途是通过[私钥加密，公钥解密]的方式来确认消息的身份(常说的数字签名算法，就是这种方式，只不过它加密的不是内容本身，而是对内容的 hash 值加密)
    - 私钥由服务器保管，服务器会向客户端颁发对应的公钥，如果客户端收到消息，能被公钥解密，就说明消息是服务器发送的

## 数字证书签发和验证流程

- 签发过程
  - 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值
  - 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名
  - 最后将 Certificate Signature 添加在文件证书上，形成数字证书
- 验证流程
  - 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1
  - 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2
  - 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信

## 对称加密

- AES:
- Chacha20:

## HTTPS 一定安全可靠吗

- HTTPS 本身到目前为止还是没有任何漏洞的
- 即使成功进入中间人攻击，本质上是利用了客户端的漏洞(网站不信任后继续访问或系统被恶意导入伪造的根证书)，并不是 HTTPS 不够安全
