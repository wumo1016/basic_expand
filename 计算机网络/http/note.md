## HTTP 是什么

- 超文本传输协议: 是一个在计算机世界里专门在两点之前传输超文本(文字、图片、音频、视频)数据的约定和规范
  - 超文本: 文字、图片、音频、视频等数据
  - 传输: 就是两点之间传输数据
  - 协议: 是一个在计算机世界里的协议, 它使用计算机能够理解的的语言确立了一种计算机之间交流通信的规范, 以及各种控制和错误处理方式

## HTTP 常见字段

- Host: 客户端发送请求时, 用来指定服务端的域名
- Content-Length: 表示本次响应的数据长度
- Content-Type: 表示本次响应的数据格式 (请求时可以通过请求头 Accept 设置可接受的数据格式)
- Content-Encoding: 表格本次响应的数据压缩方法(gzip、deflate) (请求时可以通过请求头 Accept-Encoding 设置可接受的数据格式)
- Connection: keep-alive 保持 TCP 持久连接, 以便其他请求复用(HTTP1.1 默认连接都是持久连接, 加这个字段是为了兼容老版本的 HTTP)

## 强制缓存和协商缓存

- 强缓存 (主要通过两个响应头实现 (Cache-Control 优先级更高))
  - Cache-Control
    - 相对时间(单位 s)
    - no-cache: 不缓存，但缓存中有，每次询问服务端
    - no-store: 不缓存
  - Expires: 绝对时间
- 协商缓存 (基于两种头部实现) (Etag 优先级更高)
  - 文件修改时间
    - 响应头中的 Last-Modified 表示文件最后的修改时间
    - 请求头中的 If-Modified-Since 再次发起请求的时候 带上 Last-Modified 服务端进行比对 Last-Modified 和 If-Modified-Since
      - Last-Modified > If-Modified-Since : 返回 200
      - If-Modified-Since > Last-Modified : 返回 304
  - 文件指纹
    - 响应头中的 Etag
    - 请求头中的 If-None-Match 再次发起请求的时候带上 Etag 的值 服务端进行比对 一样就返回 304 不一样就返回 200

## HTTP/1.1

- 长连接
  - 早期 HTTP1.0 一个很大的问题就是，每发起一个请求，都要建立一次 TCP 连接，而且都是串行请求，做了无谓的连接建立和断开
  - HTTP1.1 默认持久连接，只要没有任意一端明确提出断开连接，则保持 TCP 连接状态(当某个长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接)
  - 默认在请求的时候 增加 connection:keep-alive (只有一次请求应答后才能复用)
- 管道网络传输
  - 可以同时发起多个请求，但服务端必须按照请求发送的顺序发送这些请求的响应
  - 虽然请求队头不阻塞了，但没有解决响应队头阻塞
  - 虽然支持，但是存在很多问题，浏览器默认事关闭的
- 队头阻塞
  - 响应必须按顺序返回(如果前面的响应未完成，后面的则需要等待) 这称为队头阻塞
  - 所以 HTTP1.1 管道解决了请求的队头阻塞，但没有解决响应的队头阻塞
- 无状态
  - 例如需要权限的操作 每个接口都需要验证身份 它并不知道这些请求时相互关联的
  - 解决: 使用 cookie 等
- 不安全
  - 窃听风险: 通信使用明文 信息容易被窃取
  - 冒充风险: 不验证通信方的身份 因此很有可能伪装
  - 篡改风险: 无法验证报文的完整性 可能遭受篡改
  - 解决: 使用 HTTPS，加入 SLL/TLS

## HTTP/2

- 头部压缩
  - 如果同时发出多个请求，他们的头是一样的或者类似的，协议会帮你消除重复的部分
  - 利用 HPACK 算法: 在客户端和服务端同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了
    - 静态字典
      - 包含 61 个高频的头部
    - 动态字典
      - 第一次发送的时候，客户端和服务端都会更新自己的动态表，下一次请求的时候，就可以复用了，前提必须是同一个连接
    - Huffman 编码（霍夫曼编码）[https://www.rfc-editor.org/rfc/rfc7541]
- 二进制帧

  - 头信息和数据体都是二进制，并且统称为帧: 头信息帧和数据帧
  - 结构
    - 头信息帧
      - 帧长度
      - 帧类型(8 位) + 标志位(8 位)
      - R(1 位，保留位) + 流标识位(31 位，表示该帧属于哪个流，从而组装数据)
    - 数据帧
      - 它是(通过 HPACK 算法压缩过的 HTTP 头部)和包体

- 并发传输(多路复用)

  - 可以在一个请求中并发多个请求或响应，而且不用一一对应
  - 引入流的概念
    - 组成
      - 一个 TCP 可以包含多个 Stream
      - 一个 Stream 可以包含多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头和体构成
      - Message 里包含多个数据帧
    - HTTP/2 的数据包不是按顺序发送的，每个请求或响应的数据包，都称为一个数据流，每个数据流都有一个独一无二的编号(Stream ID)，接收端可以通过 Stream ID 有序的组成 HTTP 消息
    - 不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应
    - 客户端建立的 Stream ID 必须是奇数 服务端建立的 Stream ID 必须是偶数
    - 同一个域名访问多个文件的请求也可以复用一个 tcp 连接

- 服务端推送
  - 服务端可以主动向客户端发送数据，无需客户端请求
- 缺点
  - 队头阻塞
    - 只不过问题不在 HTTP 层，而是在 TCP 层(因为 TCP 层必须保证收到得字节数据是连续并且完整得)，一旦发生丢包，就会堵塞所有请求

## HTTP/3

- UDP 协议: 将 TCP 协议改成 UDP 协议
  - 由于 UDP 协议是不可靠的(不管顺序，也不管丢包)，所以在 UDP 上层添加了 QUIC 协议
- QUIC 协议
  - 无队头阻塞
    - QUIC 也使用流发送请求，可以把一个流看作一个请求，如果某个流中的数据丢失，只会阻塞这个流，其他流不会收到影响
  - 更快的连接建立
    - 由于 TCP(传输层) 和 TLS(表示层) 是分层的，所以很难合并在一起，故需要分批次握手，先 TCP 握手，再 TLS 握手
    - 而 QUIC 协议内部包含的 TLS 协议，所以只需要 QUIC 三次握手
    - 甚至在第二次连接的时候，数据包可以和 QUIC 握手信息一起发送
  - 连接迁移
    - 基于 TCP 的 HTTP 协议，是通过 TCP 四元组(源地址+源端口+目标地址+目标端口)确定一条 TCP 连接的
    - 如果设备连接的网络发生变化，就必须要重新建立连接(TCP 三次握手、TLS 四次握手、TCP 慢启动)等过程
    - 而 QUCI 协议是使用连接 ID 来标记两个通信的端点
- HTTP 层的优化
  - 帧头只有两个字段
    - 帧类型
    - 帧长度
  - 头部压缩算法使用 QPACK
    - 静态表增加到 91 个
    - 动态表编解码方式不同
    - Huffman 编码相同
- 缺点
  - QUIC 是新协议，很多网络设备根本不认识，指挥把它当作 UDP，所以如果出现丢包，就直接当作 UDP 丢掉了

## [HTTPS](https://baijiahao.baidu.com/s?id=1685474345600994715&wfr=spider&for=pc)

- 安全性

  - 混合加密
    - 对证书进行验证
    - 客户端拿到证书中的公钥，然后使用这个公钥加密[对称加密密钥]传给服务端 (公钥加密, 私钥解密 => 非对称加密)
    - 后续使用[对称加密密钥]加密解密内容 (对称加密)

- 连接建立
  - HTTP 传输建立相对简单 在 TCP 三次握手之后即可传输数据 但 HTTPS 还需要进行 SSL/TLS 的握手过程
- 端口
  - HTTP 的端口是 80 HTTP 的端口是 443
- 证书

  - HTTPS 需要向 CA(证书权威机构)申请数字证书，来保证服务端的身份是可信的

- 其他

  - TLS 由 SSL 发展而来，SSL 发展到第三代就改成了 TLS
  - HTTPS 解决了 HTTP 不安全的缺陷 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议 使得报文能够加密传输
  - 使用了混合加密(对称+非对称)
  - 数字证书
    - CA(数字证书认证机构)机构，将服务端公钥放在证书中
    - 还会对请求的域名与证书上的域名进行验证(防止了证书被伪造)
  - 解决了 HTTP 的三个风险
    - 窃听风险(比如通信链路上可以获取通信内容) => 使用信息加密(交互信息无法被窃取) => 混合加密(现信息的机密性，解决了窃听的风险)
    - 篡改风险(比如强制植入垃圾广告，视觉污染) => 使用校验机制(无法篡改通信内容，篡改了就不能正常显示) => 摘要算法(实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险)
    - 冒充风险(比如冒充淘宝网站，用户钱容易没) => 身份证书(证明淘宝是真的淘宝网) => 数字证书(将服务端公钥放入到数字证书中，解决了冒充的风险)
  - 双向验证

    - 一般我们只在客户端验证了服务端的证书的合法性
    - 服务端验证客户端的合法性一般使用 U 盾，U 盾就是内置了证书，通信时将证书传给服务端(银行转账等)

## 非对称加密

- 组成
  - 一个公钥，可以公开给所有人
  - 一个私钥，由本人管理，不可泄漏
- 加密方式(双向加密)
  - [公钥加密，私钥解密]
    - 为了保证内容传输的安全。因为只有持有私钥的人，才能解密出实际的内容
  - [私钥加密，公钥解密] => 别名 [私钥签名, 验签]
    - 为了保证消息不会被冒充。如果公钥能正常解密内容，就能证明这个内容就是持有私钥身份的人发送的
- 备注
  - 一般不会使用非对称加密来传输内容，因为非对称加密的计算比较耗费性能
  - 所以主要用途是通过[私钥加密，公钥解密]的方式来确认消息的身份(常说的数字签名算法，就是这种方式，只不过它加密的不是内容本身，而是对内容的 hash 值加密)
    - 私钥由服务端保管，服务端会向客户端颁发对应的公钥，如果客户端收到消息，能被公钥解密，就说明消息是服务端发送的

## 对称加密

- AES:
- Chacha20:

## 数字证书签发和验证流程

- 签发过程
  - 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值
  - 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature(一个签名)
  - 最后将 Certificate Signature 添加在文件证书上，形成数字证书
- 验证流程
  - 首先客户端会使用同样的 Hash 算法获取该证书的打包后的值 H1，同签发过程的第一步
  - 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密证书上的签名 Certificate Signature，得到一个 Hash 值 H2
  - 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信

## TLS 协议

- TLS 协议的基本流程
  - 客户端向服务端索要并验证服务端的公钥
  - 双方协商产生[会话密钥]
  - 双方使用[会话密钥]进行加密通信
- TLS 协议的前两步就是 TLS 的握手阶段，涉及四次通信
- 使用不同的密钥算法，TLS 握手流程也不一样，目前主要有两种算法 RSA 算法和 ECDHE 算法
  - RSA 算法
    - 握手过程
      - 第一次握手: ClientHello 客户端主要向服务端发送以下信息(TLS 协议版本号 + 随机数 C + 密码套件列表)
        - 客户端 TLS 协议版本号
        - 客户端产生的随机数 Client Random (用于生成会话密钥)
        - 客户端支持的密码套件列表，如 RSA 加密算法
      - 第二次握手: ServerHello 服务端向客户端发送响应内容(确认 TLS 协议版本 + 随机数 S + 确认的密码套件列表 + 服务端的数字证书)
        - 确认的 TLS 协议版本号(如果浏览器不支持，则关闭加密通信)
        - 服务端产生的随机数 Server Random (用于生成会话密钥)
        - 确认的密码套件列表，即 RSA 加密算法
        - 服务端的数字证书
      - 第三次握手: 客户端回应
        - 客户端首先会验证数字证书的真实性
        - 如果没问题则拿出证书中的公钥，加密发送以下信息
          - 先生成一个随机数 pre-master key, 使用公钥加密后发给服务端
          - 向服务端发送一个加密算法变更通知，表示后续信息都使用[会话密钥]加密通信
          - 向服务端发送客户端握手结束的通知(并且把所有握手的数据做个摘要一同发送，用来供服务端检验)
        - 客户端有了这三个随机数 Client Random、Server Random、pre-master key，然后就用双方协商的加密算法生成[会话密钥]
      - 第四次握手: 服务端的最后响应
        - 首先拿到客户端发送的 pre-master key，先解密拿到真实的 pre-master key，然后使用协商好的加密算法生成[会话密钥]
        - 然后向客户端发送最后的信息
          - 加密算法变更通知，表示后续信息都使用[会话密钥]加密通信
          - 服务端握手结束(并且把所有握手的数据做个摘要一同发送，用来供客户端检验)
    - 缺点
      - 如果服务器的私钥泄露，获取使用 TLS 通讯密文都会被破解，所以就出现了 ECDHE 密钥协商算法
      - 目前大多数网站使用的都是 ECDHE 算法
  - ECDHE 算法
    - 介绍
      - 离散对数
        - DH 算法的核心
        - 对数
          - 指数的逆运算
          - `y = 2 ^ x` => x 就是以 2 为底数的 y 的对数
        - 离散对数在对数运算的基础上增加了模运算
          - `y = a ^ x (mod p)` => 底数 a、离散对数 x、模数 p、真数 y
        - 即使知道真数和底数，很难反推出离散对数
      - DH 算法
        - 介绍
          - ECDHE 密钥协商算法是由 DH 算法演变而来
          - 双方各自生成一个随机数作为[私钥]，将这个私钥作为离散对数，然后通过公开的底数和模数算出真数各自的公钥 A 和 B，公开
          - 然后双方使用对方的公钥作为底数和自己的离散对数、公共的模数即可计算出一个结果 [K]，根据离散对数交换律，这两个 K 是相等的，这个 K 即对称加密密钥
        - 实现
          - 根据私钥生成方式分为两种
            - static DH 算法(已废弃): 因为有一方的私钥通常是固定不变的，所以另一方一旦被破解，就会泄露所有数据
            - DHE 算法: 每次双方都随机生成。即使有一次被破解，其他的也是安全的
      - ECDHE 算法
        - 介绍
          - 由于 DHE 算法计算性能不佳，所以出现了 ECDHE 算法
          - 利用了 ECC 椭圆曲线特性
    - 握手过程
      - 第一次握手: Client Hello 同上
        - 客户端生成的随机数 C
      - 第二次握手: Server Hello
        - 服务端生成一个随机数 S，返回给客户端
        - 密钥协商算法使用 ECDHE，返回客户端
        - 选择一个椭圆曲线(包含基点 G)，返回给客户端
        - 再生成一个随机数作为[服务端椭圆曲线私钥]保留到本地
        - 根据基点和私钥计算出[服务端椭圆曲线公钥]，使用 RSA 签名算法加密后返回给客户端
        - 服务端的数字证书
      - 第三次握手:
        - 客户端首先会验证数字证书的真实性
        - 生成一个随机数作为[客户端椭圆曲线私钥]，然后根据椭圆曲线的基点 G 计算出客户端的椭圆曲线[客户端椭圆曲线公钥]
        - 然后通过 ECDHE 算法[服务端公钥+客户端私钥+椭圆曲线基点] => [共享密钥]
        - 然后通过[客户端随机数+服务端随机数+共享密钥] => [会话密钥]
      - 第四次握手
        - 然后通过 ECDHE 算法[客户端公钥+服务端私钥+椭圆曲线基点] => [共享密钥] (共享密钥应该相等)
        - 然后通过[客户端随机数+服务端随机数+共享密钥] => [会话密钥]
    - 优点
      - 支持前向保密
      - ECDHE 密钥协商算法在第三次握手后可以不等服务端响应，直接开始发送数据，节省了一次时间

## HTTPS 一定安全可靠吗

- HTTPS 本身到目前为止还是没有任何漏洞的
- 即使成功进入中间人攻击，本质上是利用了客户端的漏洞(网站不信任后继续访问或系统被恶意导入伪造的根证书)，并不是 HTTPS 不够安全
