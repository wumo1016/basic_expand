## HTTP 是什么

- 超文本传输协议: 是一个在计算机世界里专门在两点之前传输超文本(文字、图片、音频、视频)数据的约定和规范
  - 超文本: 文字、图片、音频、视频等数据
  - 传输: 就是两点之间传输数据
  - 协议: 是一个在计算机世界里的协议, 它使用计算机能够理解的的语言确立了一种计算机之间交流通信的规范, 以及各种控制和错误处理方式

## HTTP 常见字段

- Host: 客户端发送请求时, 用来指定服务器的域名
- Content-Length: 表示本次响应的数据长度
- Content-Type: 表示本次响应的数据格式 (请求时可以通过请求头 Accept 设置可接受的数据格式)
- Content-Encoding: 表格本次响应的数据压缩方法(gzip、deflate) (请求时可以通过请求头 Accept-Encoding 设置可接受的数据格式)
- Connection: keep-alive 保持 TCP 持久连接, 以便其他请求复用(HTTP1.1 默认连接都是持久连接, 加这个字段是为了兼容老版本的 HTTP)

## 强制缓存和协商缓存

- 强缓存 (主要通过两个响应头实现 (Cache-Control 优先级更高))
  - Cache-Control
    - 相对时间(单位 s)
    - no-cache: 不缓存，但缓存中有，每次询问服务器
    - no-store: 不缓存
  - Expires: 绝对时间
- 协商缓存 (基于两种头部实现) (Etag 优先级更高)
  - 文件修改时间
    - 响应头中的 Last-Modified 表示文件最后的修改时间
    - 请求头中的 If-Modified-Since 再次发起请求的时候 带上 Last-Modified 服务器进行比对 Last-Modified 和 If-Modified-Since
      - Last-Modified > If-Modified-Since : 返回 200
      - If-Modified-Since > Last-Modified : 返回 304
  - 文件指纹
    - 响应头中的 Etag
    - 请求头中的 If-None-Match 再次发起请求的时候带上 Etag 的值 服务器进行比对 一样就返回 304 不一样就返回 200

## HTTP/1.1

- 长连接
  - 早期 HTTP1.0 一个很大的问题就是，每发起一个请求，都要建立一次 TCP 连接，而且都是串行请求，做了无谓的连接建立和断开
  - HTTP1.1 默认持久连接，只要没有任意一端明确提出断开连接，则保持 TCP 连接状态(当某个长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接)
  - 默认在请求的时候 增加 connection:keep-alive (只有一次请求应答后才能复用)
- 管道网络传输
  - 可以同时发起多个请求，但服务器必须按照请求发送的顺序发送这些请求的响应
  - 虽然请求队头不阻塞了，但没有解决响应队头阻塞
  - 虽然支持，但是存在很多问题，浏览器默认事关闭的
- 队头阻塞
  - 响应必须按顺序返回(如果前面的响应未完成，后面的则需要等待) 这称为队头阻塞
  - 所以 HTTP1.1 管道解决了请求的队头阻塞，但没有解决响应的队头阻塞
- 无状态
  - 例如需要权限的操作 每个接口都需要验证身份 它并不知道这些请求时相互关联的
  - 解决: 使用 cookie 等
- 不安全
  - 窃听风险: 通信使用明文 信息容易被窃取
  - 冒充风险: 不验证通信方的身份 因此很有可能伪装
  - 篡改风险: 无法验证报文的完整性 可能遭受篡改
  - 解决: 使用 HTTPS，加入 SLL/TLS

## HTTP/2

- 头部压缩
  - 如果同时发出多个请求，他们的头是一样的或者类似的，协议会帮你消除重复的部分
  - 利用 HPACK 算法: 在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了
    - 静态字典
      - 包含 61 个高频的头部
    - 动态字典
      - 第一次发送的时候，客户端和服务器都会更新自己的动态表，下一次请求的时候，就可以复用了，前提必须是同一个连接
    - Huffman 编码（霍夫曼编码）[https://www.rfc-editor.org/rfc/rfc7541]
- 二进制帧

  - 头信息和数据体都是二进制，并且统称为帧: 头信息帧和数据帧
  - 结构
    - 头信息帧
      - 帧长度
      - 帧类型(8 位) + 标志位(8 位)
      - R(1 位，保留位) + 流标识位(31 位，表示该帧属于哪个流，从而组装数据)
    - 数据帧
      - 它是(通过 HPACK 算法压缩过的 HTTP 头部)和包体

- 并发传输(多路复用)

  - 可以在一个请求中并发多个请求或响应，而且不用一一对应
  - 引入流的概念
    - 组成
      - 一个 TCP 可以包含多个 Stream
      - 一个 Stream 可以包含多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头和体构成
      - Message 里包含多个数据帧
    - HTTP/2 的数据包不是按顺序发送的，每个请求或响应的数据包，都称为一个数据流，每个数据流都有一个独一无二的编号(Stream ID)，接收端可以通过 Stream ID 有序的组成 HTTP 消息
    - 不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应
    - 客户端建立的 Stream ID 必须是奇数 服务端建立的 Stream ID 必须是偶数
    - 同一个域名访问多个文件的请求也可以复用一个 tcp 连接

- 服务器推送
  - 服务器可以主动向客户端发送数据，无需客户端请求
- 缺点
  - 队头阻塞
    - 只不过问题不在 HTTP 层，而是在 TCP 层(因为 TCP 层必须保证收到得字节数据是连续并且完整得)，一旦发生丢包，就会堵塞所有请求

## HTTP/3

- UDP 协议: 将 TCP 协议改成 UDP 协议
  - 由于 UDP 协议是不可靠的(不管顺序，也不管丢包)，所以在 UDP 上层添加了 QUIC 协议
- QUIC 协议
  - 无队头阻塞
    - QUIC 也使用流发送请求，可以把一个流看作一个请求，如果某个流中的数据丢失，只会阻塞这个流，其他流不会收到影响
  - 更快的连接建立
    - 由于 TCP(传输层) 和 TLS(表示层) 是分层的，所以很难合并在一起，故需要分批次握手，先 TCP 握手，再 TLS 握手
    - 而 QUIC 协议内部包含的 TLS 协议，所以只需要 QUIC 三次握手
    - 甚至在第二次连接的时候，数据包可以和 QUIC 握手信息一起发送
  - 连接迁移
    - 基于 TCP 的 HTTP 协议，是通过 TCP 四元组(源地址+源端口+目标地址+目标端口)确定一条 TCP 连接的
    - 如果设备连接的网络发生变化，就必须要重新建立连接(TCP 三次握手、TLS 四次握手、TCP 慢启动)等过程
    - 而 QUCI 协议是使用连接 ID 来标记两个通信的端点
- HTTP 层的优化
  - 帧头只有两个字段
    - 帧类型
    - 帧长度
  - 头部压缩算法使用 QPACK
    - 静态表增加到 91 个
    - 动态表编解码方式不同
    - Huffman 编码相同
- 缺点
  - QUIC 是新协议，很多网络设备根本不认识，指挥把它当作 UDP，所以如果出现丢包，就直接当作 UDP 丢掉了

## HTTPS[https://baijiahao.baidu.com/s?id=1685474345600994715&wfr=spider&for=pc]

- 安全性

  - 对证书进行验证
  - 客户端拿到证书中的公钥，然后使用这个公钥加密[对称加密密钥]传给服务器 (公钥加密, 私钥解密 => 非对称加密)
  - 后续使用[对称加密密钥]加密解密内容 (对称加密)

- 连接建立
  - HTTP 传输建立相对简单 在 TCP 三次握手之后即可传输数据 但 HTTPS 还需要进行 SSL/TLS 的握手过程
- 端口
  - HTTP 的端口是 80 HTTP 的端口是 443
- 证书

  - HTTPS 需要向 CA(证书权威机构)申请数字证书，来保证服务器的身份是可信的

- 其他

  - TLS 由 SSL 发展而来，SSL 发展到第三代就改成了 TLS
  - HTTPS 解决了 HTTP 不安全的缺陷 在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议 使得报文能够加密传输
  - 使用了混合加密(对称+非对称)
  - 数字证书
    - CA(数字证书认证机构)机构，将服务器公钥放在证书中
    - 还会对请求的域名与证书上的域名进行验证(防止了证书被伪造)
  - 解决了 HTTP 的三个风险
    - 窃听风险(比如通信链路上可以获取通信内容) => 使用信息加密(交互信息无法被窃取) => 混合加密(现信息的机密性，解决了窃听的风险)
    - 篡改风险(比如强制植入垃圾广告，视觉污染) => 使用校验机制(无法篡改通信内容，篡改了就不能正常显示) => 摘要算法(实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险)
    - 冒充风险(比如冒充淘宝网站，用户钱容易没) => 身份证书(证明淘宝是真的淘宝网) => 数字证书(将服务器公钥放入到数字证书中，解决了冒充的风险)
  - 双向验证

    - 一般我们只在客户端验证了服务端的证书的合法性
    - 服务端验证客户端的合法性一般使用 U 盾，U 盾就是内置了证书，通信时将证书传给服务端(银行转账等)

## 非对称加密

- 组成
  - 一个公钥，可以公开给所有人
  - 一个私钥，由本人管理，不可泄漏
- 加密方式(双向加密)
  - [公钥加密，私钥解密]
    - 为了保证内容传输的安全。因为只有持有私钥的人，才能解密出实际的内容
  - [私钥加密，公钥解密] => 别名 [私钥签名, 验签]
    - 为了保证消息不会被冒充。如果公钥能正常解密内容，就能证明这个内容就是持有私钥身份的人发送的
- 备注
  - 一般不会使用非对称加密来传输内容，因为非对称加密的计算比较耗费性能
  - 所以主要用途是通过[私钥加密，公钥解密]的方式来确认消息的身份(常说的数字签名算法，就是这种方式，只不过它加密的不是内容本身，而是对内容的 hash 值加密)
    - 私钥由服务器保管，服务器会向客户端颁发对应的公钥，如果客户端收到消息，能被公钥解密，就说明消息是服务器发送的

## 对称加密

- AES:
- Chacha20:

## 数字证书签发和验证流程

- 签发过程
  - 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值
  - 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature(一个签名)
  - 最后将 Certificate Signature 添加在文件证书上，形成数字证书
- 验证流程
  - 首先客户端会使用同样的 Hash 算法获取该证书的打包后的值 H1，同签发过程的第一步
  - 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密证书上的签名 Certificate Signature，得到一个 Hash 值 H2
  - 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信

## HTTPS 一定安全可靠吗

- HTTPS 本身到目前为止还是没有任何漏洞的
- 即使成功进入中间人攻击，本质上是利用了客户端的漏洞(网站不信任后继续访问或系统被恶意导入伪造的根证书)，并不是 HTTPS 不够安全
