## 基本介绍

- TCP 是面向连接的、可靠的、字节流的传输层通信协议
  - 连接的: 必须是一对一(UDP 可以一对多)
  - 可靠的: 保证数据的完整性
  - 字节流:
- 为什么需要
  - 因为 IP 层不可靠，因为它不保证包的有序性、完整性
- 建立一个 TCP 连接需要客户端与服务端达成三个共识
  - Socket: 由 IP 地址和端口号组成
  - 序列号: 用来解决乱序问题
  - 窗口大小: 用来做流程控制
- 如何确定一个 TCP 连接
  - 通过 TCP 四元组确定
    - 源地址: 在 IP 头中
    - 源端口号: 在 TCP 头中
    - 目标地址: 在 IP 头中
    - 目标端口号: 在 TCP 头中

## 三次握手

- 过程
  - 第一次
    - 客户端初始化一个序列号，放在 TCP 头部序号中
    - 将 SYN 的标志位值设置为 1
    - 发送 SYN 报文
  - 第二次
    - 服务端初始化一个序列号，放在 TCP 头部序号中
    - 将从客户端收到的序列号+1 放入 TCP 头部的确认应答号中
    - 将 SYN 和 ACK 的标志位值设置为 1
    - 发送 SYN+ACK 报文
  - 第三次
    - 将从服务端收到的序列号+1 放入 TCP 头部的确认应答号中
    - 将 ACK 的标志位值设置为 1
    - 发送 ACK 报文
- 丢失
  - 第一次
    - 会触发客户端超时重传机制
    - 每次等待的时间是上次的二倍
    - 在达到最大重传次数后，再等待上次的二倍时间，如果还没收到服务端的回应，就断开连接
  - 第二次
    - 客户端会认为第一次握手丢了，然后触发客户端的超时重传机制，同上
    - 如果服务端迟迟收不到第三次客户端 ACK，就会触发服务端的超时重传机制，重复向客户端发送 ACK+SYN 报文，同上(服务端也有最大重传次数)
  - 第三次
    - 由于服务端迟迟收不到客户端的 ACK，所以会触发服务端的超时重传机制

## 为什么需要三次握手

- 基本原因
  - 因为需要确认是否可以双向通信
  - 过程
    - A => 我可以给你打电话嘛 => B
    - B => 可以 => A
    - B => 我可以给你打电话嘛 => A
    - A => 可以 => B
  - 中间两次可以合并
- 深层原因
  - 阻止历史连接
    - 例如客户端发起第一次连接序列号为 90，此时网路阻塞
    - 网络恢复后，又发起了一个连接 序列号为 100
    - 然后第一次连接的服务端先响应，返回给客户端的确认应答号是 90+1，但客户端期望的确实 100+1
    - 所以客户端就给服务端发送一个 RST 报文，服务端收到后，就会释放这个连接
    - 客户端等待新的 SYN+ACK 报文到达后，就可以开始正确的连接了
  - 同步双方初始序列号
    - 需要确认对方都收到了自己的序列号(确认应答号)
  - 避免资源浪费
    - 同阻止历史连接，如果前面的 SYN 阻塞，则客户端超时重发，服务端收到后再与客户端建立重复连接

## 为什么每次 TCP 连接的初始化序列号不一样

- 防止历史报文被下一个相同的 TCP 四元组接收
- 防止黑客伪造相同的 TCP 报文被对方接收

## 什么是 SYN 攻击

- 介绍
  - 就是服务端每收到一个 SYN 报文，就会创建一个半连接，将其加入半连接队列
  - 当半连接队列满了以后，后续发送的报文可能会丢失
- 连接队列(linux 内核)
  - 半连接队列(SYN 队列) => 收到 SYN 报文的时候创建，收到 ACK 时取出
  - 全连接队列(accept 队列) => 收到 ACK 时从 SYN 队列中取出放入，当应用调用`accpet()`socket 接口时取出
- 解决办法
  - 调大 netdev_max_backlog
    - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包
    - 控制该队列的最大值就是这个参数 netdev_max_backlog
  - 增大 TCP 半连接队列
  - 开启 tcp_syncookies
    - 开启后，相当于绕过 SYN 队列，直接通过算法将 SYN 包计算出一个 cookie 放入第二次握手的[序列号]中
  - 减少 SYN+ACK 重传次数
    - 由于服务端收到大量的 SYN，所以会重复发送 ACK+SYN 报文，减少重传次数，可以加快断开连接

## 四次挥手

- 过程
  - 第一次
    - 客户端发送一个 TCP 头，标志位 FIN 为 1，即 FIN 报文
  - 第二次
    - 服务端收到后，就向客户端发送 ACK 应答报文
  - 第三次
    - 服务端等待数据处理完毕后，向客户端发送 FIN 报文
  - 第四次
    - 客户端收到服务端的 FIN 报文后，就向服务端发送 ACK 报文
    - 客户端等待 2MSL，然后关闭这个连接 (主动关闭的，才会等待 2MSL)
    - 服务端收到客户端的 ACK 报文后，关闭这个连接
- 丢失
  - 第一次
    - 会触发客户端超时重传机制
    - 每次等待的时间是上次的二倍
    - 在达到最大重传次数后，再等待上次的二倍时间，如果还没收到服务端的回应，就断开连接
  - 第二次
    - 由于 ACK 报文是不会重传的，所以会触发客户端的重传机制，如上
  - 第三次
    - 客户端收不到服务段的 FIN 报文，也就不会发送 ACK 报文，所以会触发服务端的超时重传
    - 由于迟迟收不到客户端发送的 ACK
  - 第四次
    - 由于迟迟收不到客户端发送的 ACK，所以会触发服务端的超时重传

## 为什么需要四次挥手

- 过程
  - A => 我们分开吧 => B
  - B => 收到 => A
  - B => 我们分开吧 => A
  - A => 可以 => B
- 由于 B 中间还需要处理一些事情 所以不能合并

## MSL

- 报文最大生存时间

## 重传机制

- 超时重传
  - 介绍: 在发送数据时，设置一个定时器，在超过指定时间后，没有收到对方的 ACK 报文，就会重发该数据
  - 触发情况
    - 数据包丢失
    - 确认应答号丢失
  - RTT: 往返时延。就是数据从发送时刻到接收到确认时刻的差值
  - RTO: 超时重传时间
    - 应该略大于 RTT
  - 缺点
    - 如果多次超时时，超时时间设置为前一次的二倍
    - 等待时间周期过长，所以有了快速重传
- 快速重传

  - 介绍: 不以时间为驱动，以数据为驱动重传
  - 触发
    - 当收到一定数量(一般为 3)的重复 ACK 时，会在定时器过期之前，重传丢失的报文 (收到失序报文时，TCP 会生成重复 ACK)
    - 例如：
      - 发送方发送 Seq1-Seq5 份数据
      - Seq1 到达，回复 ACK2
      - Seq2 丢失
      - Seq3 丢失
      - Seq4-Seq5 到达后，都回复 ACK2
  - 缺点
    - 重传一个还是所有的问题，是只重传 Seq2 (效率低。Seq3 还得接收到三个 ACK3 才能继续重传)，还是重传 Seq2 后的所有(浪费资源。Seq4-Seq5 已经传过了)
    - 为了解决重传哪些 TCP 报文，于是就有了 SACK

- SACK
  - 介绍: 选择性确认
    - 在 TCP 头部选项字段中，加一个 SACK，它可将已接收的东西传给发送方，这样发送就可以只重传丢失的数据
- D-SACK(Duplicate SACK)
  - 介绍:
    - 主要通过 SACK 告诉发送方哪些数据被重复接收了
  - 好处
    - 通过 ACK + SACK 可以让发送方知道，是还是接收方回应的 ACK 报文丢了还是网络延迟了

## 滑动窗口

- 介绍
  - 窗口的实现实际就是在操作系统中开辟一个缓存空间, 就是(无需等待应答, 可以继续发送数据的最大空间 / 可以接收数据的最大空间)
  - TCP 头里有一个 Window 字段，就是窗口大小。这个字段就是接收方告诉发送方自己还有多少缓存区可以接收数据
  - 当接受区的缓存区满的时候, 每隔一段时间, 发送方会发送一个探测包来询问是否能够调整窗口大小
  - 当上层协议消耗掉了接受方的数据的时候 接收方也会主动通知发送方调整窗口 继续发送数据
- 窗口分类
  - 发送方的滑动窗口(swnd)
    - 程序表示
      - SND.WND: 窗口大小, 由接收方指定
      - SND.UNA: 绝对指针, 它指向已发送但没有收到确认的第一个字节的系列号(滑动窗口的开头位置)
      - SND.NXT: 绝对指针, 它执行位发送但是可发送的第一个字节的序列号(滑动窗口可用部分的开头位置)
      - 由上可以计算出可用窗口大小: `SND.WND - (SND.NXT - SND.UNA)`
  - 接收方的滑动窗口(rwnd)
    - 程序表示
      - RCV.WND: 窗口大小, 会告诉发送方
      - RCV.NXT: 期望发送方发送来下一个数据字节的序列号
    - 通常窗口大小是由接收方的窗口大小决定的

## 流量控制

- 介绍
  - TCP 通过让接收方指明(希望从发送方接收的)数据大小来进行流量控制
- 糊涂窗口综合症
  - 介绍
    - 只传输几个字节的数据, 而 TCP+IP 头部就有 40 个字节, 这样很不划算
  - 触发
    - 接收方通知发送方一个小窗口
    - 发送方发送小数据
  - 解决
    - 接收方(接受方不通知小窗口)
      - 通常的策略是当窗口大小小于 min(MSS, 缓存空间 / 2), 就是小于窗口大小一般的时候, 就向发送方通告窗口为 0
    - 发送方
      - 使用 Nagle 算法, 必须满足下面条件的任意一个, 才可以发送数据
        - 窗口大小 >= MSS && 可发送的数据大小 >= MSS
        - 收到之前数据的 ACK 回包(如果接收方不满足不通知小窗口这个条件, 还是无法解决的)
    - 所以必须满足两个条件才能避免糊涂窗口: 接收方不通知小窗口 + 发送方开启 Nagle 算法

## 拥塞处理

- 拥塞窗口(cwnd)

  - 发送方维护的一个状态变量, 它会根据网路的拥塞程度动态变化
  - 有了拥塞窗口, 发送窗口 = min(接收窗口, 拥塞窗口)
  - 变化规则: 网路拥塞(只要在发送方没有在规定时间内收到 ACK 应答报文, 就认为网路出现了拥塞)就减小, 没有就增大

- 拥塞控制的四个算法

  - 慢启动
    - 介绍
      - 一点点的提高发送数据的数量
    - 规则
      - 发送方每收到一个 ACK, 拥塞窗口 cwnd 就加 1
      - 上限: 有一个慢启动门限状态变量(ssthresh)
        - cwnd < ssthresh, 就使用[慢启动算法]
        - cwnd >= ssthresh, 就使用[拥塞避免算法]
  - 拥塞避免
    - 每当收到一个 ACK, cwnd 就增加 1/cwnd
    - 其实就是将原本慢启动的指数级增长变成了线性增长, 但还是增长阶段
    - 就这样一直增长, 就会丢包, 触发重传机制, 也就进入了拥塞发生算法
  - 拥塞发生
    - 超时重传触发
      - ssthresh 设置为 cwnd / 2
      - cwnd 重置为初始化值
      - 重新开始慢启动
    - 快速重传触发
      - cwnd 设置为 cwnd / 2
      - ssthresh 等于 cwnd
      - 进入快速恢复算法
  - 快速恢复
    - cwnd = ssthresh + 3 (加 3 代表收到了 3 个重复的 ACK)
    - 随后重传丢失的包, 如果再收到重复的 ACK, cwnd 加 1
    - 如果收到新的 ACK, cwnd 设置为第一步 ssthresh 的值, 快恢复过程结束, 进入拥塞避免
    - cwnd 大时因为对慢启动的优化, 尽快的将丢失的数据发给目标

## 粘包(Cork 算法)

- Nagle 算法: 在同一时刻只能有一个未被确认的小段，但如果大佛那个比较快的话，是看不到效果的
- Cork 算法: 当达到 MSS(最大段大小)值时统一发送(此值就是帧的大小 - ip 头 20 个字节 - tacp 头 20 个字节 = 1460 个字节)(具体大小和本地环境有关)

## 缺点

- 队头阻塞
  - 后面的包先到达就需要等待前面的包返回之后才可以继续传输
- 慢启动
  - 好性能
- time-wait
  - 客户端连接服务器(会默认开启一个端口)后不会立即断开，在高并发短链接的情况下，会出现端口被占用的情况

## 名词

- RTT: 往返时延
- RTO: 超时重传时间
- MTU: 一个网络包的最大长度, 一般为 1500 字节
- MSS: 一个网络包所能容纳的 TCP 数据的最大长度, 就是 MTU 的长度减去 IP 和 TCP 头部的长度
