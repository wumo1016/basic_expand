## 基本介绍

- TCP 是面向连接的、可靠的、字节流的传输层通信协议
  - 连接的: 必须是一对一(UDP 可以一对多)
  - 可靠的: 保证数据的完整性
  - 字节流:
- 为什么需要
  - 因为 IP 层不可靠，因为它不保证包的有序性、完整性
- 建立一个 TCP 连接需要客户端与服务端达成三个共识
  - Socket: 由 IP 地址和端口号组成
  - 序列号: 用来解决乱序问题
  - 窗口大小: 用来做流程控制
- 如何确定一个 TCP 连接
  - 通过 TCP 四元组确定
    - 源地址: 在 IP 头中
    - 源端口号: 在 TCP 头中
    - 目标地址: 在 IP 头中
    - 目标端口号: 在 TCP 头中

## 三次握手

- 过程
  - 第一次
    - 客户端初始化一个序列号，放在 TCP 头部序号中
    - 将 SYN 的标志位值设置为 1
    - 发送 SYN 报文
  - 第二次
    - 服务端初始化一个序列号，放在 TCP 头部序号中
    - 将从客户端收到的序列号+1 放入 TCP 头部的确认应答号中
    - 将 SYN 和 ACK 的标志位值设置为 1
    - 发送 SYN+ACK 报文
  - 第三次
    - 将从服务端收到的序列号+1 放入 TCP 头部的确认应答号中
    - 将 ACK 的标志位值设置为 1
    - 发送 ACK 报文
- 丢失
  - 第一次
    - 会触发客户端超时重传机制
    - 每次等待的时间是上次的二倍
    - 在达到最大重传次数后，再等待上次的二倍时间，如果还没收到服务端的回应，就断开连接
  - 第二次
    - 客户端会认为第一次握手丢了，然后触发客户端的超时重传机制，同上
    - 如果服务端迟迟收不到第三次客户端 ACK，就会触发服务端的超时重传机制，重复向客户端发送 ACK+SYN 报文，同上(服务端也有最大重传次数)
  - 第三次
    - 由于服务端迟迟收不到客户端的 ACK，所以会触发服务端的超时重传机制

## 为什么需要三次握手

- 基本原因
  - 因为需要确认是否可以双向通信
  - 过程
    - A => 我可以给你打电话嘛 => B
    - B => 可以 => A
    - B => 我可以给你打电话嘛 => A
    - A => 可以 => B
  - 中间两次可以合并
- 深层原因
  - 阻止历史连接
    - 例如客户端发起第一次连接序列号为 90，此时网路阻塞
    - 网络恢复后，又发起了一个连接 序列号为 100
    - 然后第一次连接的服务端先响应，返回给客户端的确认应答号是 90+1，但客户端期望的确实 100+1
    - 所以客户端就给服务端发送一个 RST 报文，服务端收到后，就会释放这个连接
    - 客户端等待新的 SYN+ACK 报文到达后，就可以开始正确的连接了
  - 同步双方初始序列号
    - 需要确认对方都收到了自己的序列号(确认应答号中)
  - 避免资源浪费
    - 同阻止历史连接，如果前面的 SYN 阻塞，则客户端超时重发，服务端收到后再与客户端建立重复连接

## 为什么每次 TCP 连接的初始化序列号不一样

- 防止历史报文被下一个相同的 TCP 四元组接收
- 防止黑客伪造相同的 TCP 报文被对方接收

## 什么是 SYN 攻击

- 介绍
  - 就是服务端每收到一个 SYN 报文，就会创建一个半连接，将其加入半连接队列
  - 当半连接队列满了以后，后续发送的报文可能会丢失
- 连接队列(linux 内核)
  - 半连接队列(SYN 队列) => 收到 SYN 报文的时候创建，收到 ACK 时取出
  - 全连接队列(accept 队列) => 收到 ACK 时从 SYN 队列中取出放入，当应用调用`accpet()`socket 接口时取出
- 解决办法
  - 调大 netdev_max_backlog
    - 当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包
    - 控制该队列的最大值就是这个参数 netdev_max_backlog
  - 增大 TCP 半连接队列
  - 开启 tcp_syncookies
    - 开启后，相当于绕过 SYN 队列，直接通过算法将 SYN 包计算出一个 cookie 放入第二次握手的[序列号]中
  - 减少 SYN+ACK 重传次数
    - 由于服务端收到大量的 SYN，所以会重复发送 ACK+SYN 报文，减少重传次数，可以加快断开连接

## 为什么需要四次挥手

- 过程
  - A => 我们分开吧 => B
  - B => 收到 => A
  - B => 我们分开吧 => A
  - A => 可以 => B
- 由于 B 中间还需要处理一些事情 所以不能合并

## 滑动窗口

- 因为 TCP 是全双工的 意思就是可以互相发送消息
- 客户端发送的数据据 => 接受方的缓存区
  - 一共 7 条数据
  - 第一次 3 => 3
  - 第二次 接受方只能接受 2 个数据了 客户端往后移动三个位置 然后调整窗口大小为 2 然后发送
  - 第三次 由于接收方缓存区已满 所有客户端将窗口调整为 0 停止发送 等待 http 读取接收方缓存区内容后
  - 但由于发送的时候可能第 2 条数据先到 然后等 1 完成后 客户端就可以往后滑动了 接收方也可以同时向后滑动了
  - 后面的数据如果先到了 就需要等待前面的数据接受完毕再向后滑动
- 特点
  - 客户端和服务端都有自己的缓存区
  - 发送数据的时候是乱序发送的
  - 当接受区的缓存区满的时候 每隔一段时间 发送方会发送一个探测包来询问是否能够调整窗口大小 (当上层协议消耗掉了接受方的数据的时候 接收方也会主动通知发送方调整窗口 继续发送数据)
  - 流量控制 控制发送方的频率

## 粘包(Cork 算法)

- Nagle 算法: 在同一时刻只能有一个未被确认的小段，但如果大佛那个比较快的话，是看不到效果的
- Cork 算法: 当达到 MSS(最大段大小)值时统一发送(此值就是帧的大小 - ip 头 20 个字节 - tacp 头 20 个字节 = 1460 个字节)(具体大小和本地环境有关)

## 拥塞处理

- TCP 维护一个拥塞窗口 cwnd 变量 在传输过程中没有拥塞就将此值增大。如果出现拥塞(超时重传 RTO) 就将窗口值减少
- 慢启动 => 指数增长 => 到达 ssthresh 值 => 线性增长 => 网络阻塞
- 从新开始传输 => 慢启动 => 指数增长 => 到达 新的 ssthresh 值 (比之前小) => 线性增长
- 使用快重 快恢复传策略

## 缺点

- 队头阻塞
  - 后面的包先到达就需要等待前面的包返回之后才可以继续传输
- 慢启动
  - 好性能
- time-wait
  - 客户端连接服务器(会默认开启一个端口)后不会立即断开，在高并发短链接的情况下，会出现端口被占用的情况
