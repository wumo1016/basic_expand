## TCP 协议

- TCP 提供全双工服务

## 为什么需要三次握手

- 因为需要确认是否可以双向通信
- 过程
  - A => 我可以给你打电话嘛 => B
  - B => 可以 => A
  - B => 我可以给你打电话嘛 => A
  - A => 可以 => B
- 中间两次可以合并

## 为什么需要四次挥手

- 过程
  - A => 我们分开吧 => B
  - B => 收到 => A
  - B => 我们分开吧 => A
  - A => 可以 => B
- 由于 B 中间还需要处理一些事情 所以不能合并

## 滑动窗口

- 因为 TCP 是全双工的 意思就是可以互相发送消息
- 客户端发送的数据据 => 接受方的缓存区
  - 一共 7 条数据
  - 第一次 3 => 3
  - 第二次 接受方只能接受 2 个数据了 客户端往后移动三个位置 然后调整窗口大小为 2 然后发送
  - 第三次 由于接收方缓存区已满 所有客户端将窗口调整为 0 停止发送 等待 http 读取接收方缓存区内容后
  - 但由于发送的时候可能第 2 条数据先到 然后等 1 完成后 客户端就可以往后滑动了 接收方也可以同时向后滑动了
  - 后面的数据如果先到了 就需要等待前面的数据接受完毕再向后滑动
- 特点
  - 客户端和服务端都有自己的缓存区
  - 发送数据的时候是乱序发送的
  - 当接受区的缓存区满的时候 每隔一段时间 发送方会发送一个探测包来询问是否能够调整窗口大小 (当上层协议消耗掉了接受方的数据的时候 接收方也会主动通知发送方调整窗口 继续发送数据)
  - 流量控制 控制发送方的频率

## 粘包(Cork 算法)

- Nagle 算法: 在同一时刻只能有一个未被确认的小段，但如果大佛那个比较快的话，是看不到效果的
- Cork 算法: 当达到 MSS(最大段大小)值时统一发送(此值就是帧的大小 - ip 头 20 个字节 - tacp 头 20 个字节 = 1460 个字节)(具体大小和本地环境有关)

## 拥塞处理

- TCP 维护一个拥塞窗口 cwnd 变量 在传输过程中没有拥塞就将此值增大。如果出现拥塞(超时重传 RTO) 就将窗口值减少
- 慢启动 => 指数增长 => 到达 ssthresh 值 => 线性增长 => 网络阻塞
- 从新开始传输 => 慢启动 => 指数增长 => 到达 新的 ssthresh 值 (比之前小) => 线性增长
- 使用快重 快恢复传策略

## 缺点

- 队头阻塞
- 慢启动
- 短连接
